<h1>Welcome to Python Programming</h1>

<p>
Welcome to the world of <b>Python Programming</b>!
Python is a high-level, interpreted, and easy-to-learn programming language.
It is widely used by beginners and professionals to build simple to complex
applications.
</p>


<hr>

<p>
Python focuses on code readability and simplicity, which means you can write
programs using fewer lines of code compared to other programming languages.
Because of this, Python is an excellent choice for learning programming.
</p>

<ul>
    <li>Easy to learn and understand</li>
    <li>Beginner-friendly syntax</li>
    <li>Used in web development, data science, AI, and automation</li>
    <li>Free and open-source</li>
</ul>

<p>
Start learning Python today and open the door to endless possibilities in
software development and technology.
</p>

<h1> Python Roadmap</h1>

<hr>

<h3>1.Basic Python</h3>

<h3>2. Intermediate Python</h3>

<h3>3. Advanced Python</h3>

<h1>1. Basic Python</h1>

<p>
Basic Python includes the core concepts that help beginners start programming
using Python. These concepts form the foundation for learning intermediate
and advanced Python.
</p>

<h1>Introduction to Python </h1>

<p>
Python is a <b>high-level</b>, <b>interpreted</b>, and <b>general-purpose</b>
programming language. It is easy to learn and simple to use, which makes
it one of the best choices for beginners as well as professionals.
</p>

<img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Python-logo-notext.svg"
     alt="Python Logo" width="180">

<hr>

<h2>What is Python?</h2>

<p>
Python is a programming language used to write programs that can perform
various tasks such as data processing, web development, automation,
and artificial intelligence.
</p>

<hr>

<h2>History of Python</h2>

<ul> 
    <li>Created by <b>Guido van Rossum</b></li>
    <li>First released in <b>1991</b></li>
    <li>Named after <b>Monty Python’s Flying Circus</b></li>
</ul>

<hr>

<h2>Why Learn Python?</h2>

<ul>
    <li>Easy to learn and understand</li>
    <li>Simple and readable syntax</li>
    <li>Beginner-friendly language</li>
    <li>Large community support</li>
    <li>Free and open-source</li>
</ul>

<hr>

<h2>Features of Python</h2>

<ul>
    <li>Easy-to-read syntax</li>
    <li>Interpreted language</li>
    <li>Dynamically typed</li>
    <li>Object-Oriented Programming support</li>
    <li>Platform independent</li>
    <li>Large standard library</li>
</ul>

<hr>

<h2>Applications of Python</h2>

<ul>
    <li>Web Development (Django, Flask)</li>
    <li>Data Science and Data Analysis</li>
    <li>Artificial Intelligence and Machine Learning</li>
    <li>Automation and Scripting</li>
    <li>Game Development</li>
</ul>

<hr>

<h2>First Python Program</h2>

<p>Example:</p>

<pre>
print("Hello, World!")
</pre>

<p><b>Output:</b></p>

<pre>
Hello, World!
</pre>

<hr>

<h1>Comments in Python</h1>

<p>
<b>Comments in Python</b> are used to explain the code.
They help programmers understand the purpose of the code and
make the program more readable. Comments are ignored by the Python interpreter,
which means they are not executed.
</p>

<hr>

<h2>Types of Comments in Python</h2>

<h3>1. Single-Line Comment</h3>

<p>
Single-line comments start with the <b>#</b> symbol.
Everything after <b>#</b> on the same line is treated as a comment.
</p>

<pre>
# This is a single-line comment
print("Hello, Python")
</pre>

<hr>

<h3>2. Multi-Line Comment</h3>

<p>
Python does not have a special syntax for multi-line comments.
However, multi-line comments are usually written using multiple
single-line comments.
</p>

<pre>
# This is a multi-line comment
# It is written using
# multiple single-line comments
</pre>
<p>
Triple quotes (<b>'''</b> or <b>"""</b>) can also be used,
but they are mainly used for documentation strings (docstrings).
</p>

<pre>
"""
This is a multi-line string
often used as a documentation comment
"""
</pre>

<h1> Print Statements in python </h1>

<p>
The <b>print()</b> function in Python is used to display output on the screen.
It is one of the most important functions for beginners to learn how to
show results in Python programs.
</p>

<hr>

<h2>1. Basic Print</h2>

<pre>
print("Hello, Python!")
</pre>

<p><b>Output:</b></p>
<pre>
Hello, Python!
</pre>

<hr>

<h2>2. Printing Numbers</h2>

<pre>
print(10)
print(3.14)
</pre>

<p><b>Output:</b></p>
<pre>
10
3.14
</pre>

<hr>

<h2>3. Printing Multiple Values</h2>

<p>
You can print multiple values in one print statement separated by commas:
</p>

<pre>
print("Python", "is", "easy")
</pre>

<p><b>Output:</b></p>
<pre>
Python is easy
</pre>

<hr>

<h2>4. Using Separator (sep)</h2>

<p>
You can customize the separator between multiple values using <b>sep</b>:
</p>

<pre>
print("Python", "is", "fun", sep="-")
print("2026", "01", "04", sep="/")
</pre>

<p><b>Output:</b></p>
<pre>
Python-is-fun
2026/01/04
</pre>

<hr>

<h2>5. Printing Variables</h2>

<p>
You can store values in variables and print them:
</p>

<pre>
name = "Alice"
age = 20
print("Name:", name)
print("Age:", age)
</pre>

<p><b>Output:</b></p>
<pre>
Name: Alice
Age: 20
</pre>

<hr>

<h2>6. Using f-Strings (Formatted Strings)</h2>

<p>
Python 3.6+ supports <b>f-strings</b> for formatting output easily:
</p>

<pre>
name = "Alice"
age = 20
print(f"My name is {name} and I am {age} years old.")
</pre>

<p><b>Output:</b></p>
<pre>
My name is Alice and I am 20 years old.
</pre>

<hr>

<h2>7. Printing Without Newline (end Parameter)</h2>

<p>
By default, <b>print()</b> adds a newline at the end. You can change it using <b>end</b>:
</p>

<pre>
print("Hello,", end=" ")
print("World!")
</pre>

<p><b>Output:</b></p>
<pre>
Hello, World!
</pre>

<hr>

<h2>8. Combining f-Strings with Separator</h2>

<pre>
a = 10
b = 20
print(f"Numbers are {a} and {b}", sep=",")
</pre>

<p><b>Output:</b></p>
<pre>
Numbers are 10 and 20
</pre>
<h1>Installatin of python </h1>

<h2>1. Download Python</h2>

<ul>
    <li>Open any web browser</li>
    <li>Go to the official Python website:
        <b>https://www.python.org</b>
    </li>
    <li>Click on <b>Downloads</b></li>
    <li>Download the latest stable version of Python</li>
</ul>

<img src="https://www.python.org/static/community_logos/python-logo.png"
     alt="Python Official Logo" width="220">
<h2>2. Verify Python Installation</h2>
<pre>
python --version
</pre>

<p>or</p>

<pre>
python3 --version
</pre>
<hr>

<h2>3. Run Your First Python Program</h2>

<p>Create a file named <b>hello.py</b> and write:</p>

<pre>
print("Hello, Python!")
</pre>

<p>Run the program:</p>

<pre>
python hello.py
</pre>
<h1>Data Types in Python</h1>

<h2>what is Data Type?</h2>

<p>
A <b>data type</b> specifies the type of value a variable can store, such as numbers, text, or collections. 
Python automatically detects the type of a variable based on the value assigned.
</p>

<hr>

<h2>Importance of Data Types</h2>

<ul>
    <li>Helps the interpreter understand how to use the data</li>
    <li>Prevents errors during calculations or operations</li>
    <li>Allows efficient memory usage</li>
    <li>Helps programmers organize and manage data properly</li>
</ul>


<p>
In Python, <b>data types</b> are used to define the type of a variable or value.
Python is a dynamically typed language, which means you don’t need to declare
the type explicitly. The interpreter assigns the type automatically.
</p>

<hr>

<h2>1. Numeric Data Types</h2>

<p>
Used to store numbers.
</p>

<ul>
    <li><b>int</b> - Integer numbers</li>
    <li><b>float</b> - Decimal numbers</li>
    <li><b>complex</b> - Complex numbers (a + bj)</li>
</ul>

<h3>Examples:</h3>

<pre>
a = 10       # int
b = 3.14     # float
c = 2 + 3j   # complex

print(a)
print(b)
print(c)
</pre>

<p><b>Output:</b></p>

<pre>
10
3.14
(2+3j)
</pre>

<hr>

<h2>2. Text Type</h2>

<p>
Used to store text or characters.
</p>

<ul>
    <li><b>str</b> - String</li>
</ul>

<h3>Example:</h3>

<pre>
name = "Alice"
greeting = 'Hello, World!'

print(name)
print(greeting)
</pre>

<p><b>Output:</b></p>

<pre>
Alice
Hello, World!
</pre>

<hr>

<h2>3. Boolean Type</h2>

<p>
Used to store <b>True</b> or <b>False</b> values.
</p>

<h3>Example:</h3>

<pre>
is_student = True
is_teacher = False

print(is_student)
print(is_teacher)
</pre>

<p><b>Output:</b></p>

<pre>
True
False
</pre>

<hr>

<h2>4. Sequence Data Types</h2>

<ul>
    <li><b>list</b> - Ordered, mutable collection <br>
        <i>Example:</i> my_list = [1, 2, 3, "Python"]</li>
    <li><b>tuple</b> - Ordered, immutable collection <br>
        <i>Example:</i> my_tuple = (1, 2, 3, "Python")</li>
    <li><b>range</b> - Sequence of numbers <br>
        <i>Example:</i> my_range = range(5)</li>
</ul>

<h3>Example:</h3>

<pre>
my_list = [1, 2, 3, "Python"]
my_tuple = (4, 5, 6)
my_range = range(5)

print(my_list)
print(my_tuple)
print(list(my_range))
</pre>

<p><b>Output:</b></p>

<pre>
[1, 2, 3, 'Python']
(4, 5, 6)
[0, 1, 2, 3, 4]
</pre>

<hr>

<h2>5. Set Data Type</h2>

<p>
Used to store unordered and unique elements.
</p>

<h3>Example:</h3>

<pre>
my_set = {1, 2, 3, 2, 1}
print(my_set)
</pre>

<p><b>Output:</b></p>

<pre>
{1, 2, 3}
</pre>

<h1>Variables in Python</h1>

<p>
A <strong>variable</strong> in Python is used to store data in memory.
It acts as a container for values such as numbers, text, or objects.
</p>

<h2>What is a Variable?</h2>
<p>
A variable is a name that refers to a value. In Python, you do not need to
declare the type of a variable explicitly. The type is decided automatically
based on the value assigned.
</p>

<h2>Creating Variables</h2>
<p>
Variables are created when you assign a value using the <code>=</code> operator.
</p>

<pre>
x = 10
name = "Python"
price = 99.5
</pre>

<h2>Rules for Naming Variables</h2>
<ul>
  <li>Variable names must start with a letter or underscore (_)</li>
  <li>They cannot start with a number</li>
  <li>Only letters, numbers, and underscores are allowed</li>
  <li>Variable names are case-sensitive</li>
  <li>Keywords cannot be used as variable names</li>
</ul>

<h2>Valid Variable Names</h2>
<pre>
age = 25
_total = 100
student_name = "Pavani"
</pre>

<h2>Invalid Variable Names</h2>
<pre>
1name = "Error"
total-price = 500
class = "Python"
</pre>

<h2>Assigning Multiple Values</h2>
<p>
Python allows assigning multiple variables in a single line.
</p>

<pre>
a, b, c = 10, 20, 30
</pre>

<h2>Same Value to Multiple Variables</h2>
<pre>
x = y = z = 50
</pre>

<h2>Dynamic Typing</h2>
<p>
Python is dynamically typed, meaning a variable can change its data type.
</p>

<pre>
x = 10
x = "Hello"
</pre>

<h2>Checking Variable Type</h2>
<pre>
x = 10
print(type(x))
</pre>

<h1>Why Do We Use Variables?</h1>

<p>
Variables are used in Python to <strong>store data values</strong> so that they
can be <strong>reused, modified, and processed</strong> easily throughout a program.
</p>

<h2>Reasons for Using Variables</h2>

<h3>1. Store Data</h3>
<p>
Variables allow us to store different types of data such as numbers, text,
and results of calculations.
</p>
<pre>
age = 25
</pre>

<h3>2. Reuse Values</h3>
<p>
Once a value is stored in a variable, it can be used multiple times in the program.
</p>
<pre>
price = 100
total = price + 20
</pre>

<h3>3. Improve Code Readability</h3>
<p>
Meaningful variable names make programs easier to read and understand.
</p>
<pre>
marks = 85
</pre>

<h3>4. Modify Data Easily</h3>
<p>
The value stored in a variable can be updated whenever required.
</p>
<pre>
count = 1
count = count + 1
</pre>

<h3>5. Perform Calculations</h3>
<p>
Variables help perform arithmetic and logical operations efficiently.
</p>
<pre>
a = 10
b = 5
result = a + b
</pre>

<h3>6. Store User Input</h3>
<p>
Variables store values entered by the user during program execution.
</p>
<pre>
name = input("Enter your name: ")
</pre>

<h1>Type Conversions in Python</h1>

<p>
<strong>Type conversion</strong> in Python refers to the process of converting
one data type into another. Python supports both <strong>implicit</strong> and
<strong>explicit</strong> type conversion.
</p>

<h2>Types of Type Conversion</h2>
<ul>
  <li>1.Implicit Type Conversion</li>
  <li>2.Explicit Type Conversion (Type Casting)</li>
</ul>

<h2>1. Implicit Type Conversion</h2>
<p>
In implicit type conversion, Python automatically converts one data type
to another without user intervention. This usually happens when different
data types are used together in an expression.
</p>

<pre>
a = 10
b = 2.5
result = a + b
print(result)
</pre>

<p>
In the above example, Python converts the integer value <code>10</code> into
a float automatically.
</p>

<h2>2. Explicit Type Conversion (Type Casting)</h2>
<p>
In explicit type conversion, the programmer manually converts one data type
to another using built-in functions.
</p>

<h3>Common Type Casting Functions</h3>
<ul>
  <li><code>int()</code> – converts to integer</li>
  <li><code>float()</code> – converts to float</li>
  <li><code>str()</code> – converts to string</li>
  <li><code>bool()</code> – converts to boolean</li>
</ul>

<h3>Examples of Explicit Type Conversion</h3>

<h1>Common Type Conversions in Python</h1>

<p>
Python allows converting one data type into another using built-in
type casting functions. Below are <strong>six common types of type conversions</strong>
with examples.
</p>

<h2>1. Integer to Float</h2>
<p>
Converts an integer value into a floating-point number.
</p>
<pre>
x = 10
y = float(x)
print(y)
</pre>

<h2>2. Integer to String</h2>
<p>
Converts an integer value into a string.
</p>
<pre>
x = 25
y = str(x)
print(y)
</pre>

<h2>3. Float to Integer</h2>
<p>
Converts a float value into an integer. The decimal part is removed.
</p>
<pre>
x = 9.8
y = int(x)
print(y)
</pre>

<h2>4. Float to String</h2>
<p>
Converts a float value into a string.
</p>
<pre>
x = 3.14
y = str(x)
print(y)
</pre>

<h2>5. String to Integer</h2>
<p>
Converts a numeric string into an integer.
</p>
<pre>
x = "50"
y = int(x)
print(y)
</pre>

<h2>6. String to Float</h2>
<p>
Converts a numeric string into a floating-point number.
</p>
<pre>
x = "7.5"
y = float(x)
print(y)
</pre>

<h1>Python Operators</h1>

<p>
Operators in Python are special symbols used to <strong>perform operations</strong>
on variables and values, such as arithmetic calculations, comparisons, and
logical decisions.
</p>

<h2>Types of Operators in Python</h2>
<ul>
  <li>1.Arithmetic Operators</li>
  <li>2.Assignment Operators</li>
  <li>3.Comparison (Relational) Operators</li>
  <li>4.Logical Operators</li>
  <li>5.Bitwise Operators</li>
  <li>6.Membership Operators</li>
</ul>

<hr>

<h2>1. Arithmetic Operators</h2>
<p>Used to perform mathematical operations.</p>

<pre>
+   Addition
-   Subtraction
*   Multiplication
/   Division
%   Modulus
**  Exponentiation
//  Floor Division
</pre>

<pre>
a = 10
b = 3
print(a + b)
print(a % b)
print(a ** b)
</pre>

<hr>

<h2>2. Assignment Operators</h2>
<p>Used to assign values to variables.</p>

<pre>
=   Assign
+=  Add and assign
-=  Subtract and assign
*=  Multiply and assign
/=  Divide and assign
%=  Modulus and assign
</pre>

<pre>
x = 5
x += 3
print(x)
</pre>

<hr>

<h2>3. Comparison (Relational) Operators</h2>
<p>Used to compare two values and return True or False.</p>

<pre>
==  Equal to
!=  Not equal to
>   Greater than
<   Less than
>=  Greater than or equal to
<=  Less than or equal to
</pre>

<pre>
a = 10
b = 20
print(a > b)
</pre>

<hr>

<h2>4. Logical Operators</h2>
<p>Used to combine conditional statements.</p>

<pre>
and   Logical AND
or    Logical OR
not   Logical NOT
</pre>

<pre>
x = 10
y = 5
print(x > 5 and y < 10)
</pre>

<hr>

<h2>5. Bitwise Operators</h2>
<p>Used to perform operations at the bit level.</p>

<pre>
&   AND
|   OR
^   XOR
~   NOT
<<  Left Shift
>>  Right Shift
</pre>

<pre>
a = 5
b = 3
print(a & b)
</pre>

<hr>

<h2>6. Membership Operators</h2>
<p>Used to test whether a value is present in a sequence.</p>

<pre>
in       Returns True if value is present
not in   Returns True if value is not present
</pre>

<pre>
x = [1, 2, 3]
print(2 in x)
</pre>

<h1>Python Libraries</h1>

<h2>What is a Library?</h2>
<p>
A <strong>library</strong> is a collection of pre-written code, modules, and
functions that helps programmers perform common tasks easily without
writing code from scratch.
</p>

<p>
Libraries improve productivity by providing ready-made solutions for
tasks such as mathematical calculations, data processing, file handling,
and web development.
</p>

<hr>

<h2>Libraries in Python</h2>
<p>
Python provides a rich set of libraries that make it a powerful and
easy-to-use programming language.
</p>

<h3>1. Standard Libraries</h3>
<p>
These libraries come pre-installed with Python.
</p>

<ul>
  <li><strong>math</strong> – mathematical operations</li>
  <li><strong>random</strong> – generate random numbers</li>
  <li><strong>datetime</strong> – date and time operations</li>
  <li><strong>os</strong> – operating system interactions</li>
  <li><strong>sys</strong> – system-specific parameters</li>
</ul>

<pre>
import math
print(math.sqrt(16))
</pre>

<hr>

<h3>2. Third-Party Libraries</h3>
<p>
These libraries are developed by the Python community and must be
installed separately using <code>pip</code>.
</p>

<ul>
  <li><strong>numpy</strong> – numerical computing</li>
  <li><strong>pandas</strong> – data analysis</li>
  <li><strong>matplotlib</strong> – data visualization</li>
  <li><strong>requests</strong> – HTTP requests</li>
  <li><strong>django</strong> – web development</li>
</ul>

<pre>
pip install numpy
</pre>

<hr>

<h3>3. User-Defined Libraries</h3>
<p>
These are custom libraries created by programmers to organize their own code.
</p>

<pre>
# mylibrary.py
def add(a, b):
    return a + b
</pre>

<pre>
import mylibrary
print(mylibrary.add(5, 3))
</pre>

<hr>

<h2>Advantages of Using Libraries</h2>
<ul>
  <li>Saves time and effort</li>
  <li>Reduces code complexity</li>
  <li>Improves code reusability</li>
  <li>Enhances productivity</li>
</ul>

<h1>Built-in Functions in Python</h1>

<p>
<strong>Built-in functions</strong> in Python are pre-defined functions that are
available by default. These functions help perform common tasks without
importing any library.
</p>

<h2>Why Use Built-in Functions?</h2>
<ul>
  <li>No need to import modules</li>
  <li>Easy to use</li>
  <li>Save development time</li>
  <li>Improve code readability</li>
</ul>

<hr>

<h2>Common Built-in Functions in Python</h2>

<h3>1. print()</h3>
<p>Displays output on the screen.</p>
<pre>
print("Hello Python")
</pre>

<h3>2. input()</h3>
<p>Accepts input from the user.</p>
<pre>
name = input("Enter your name: ")
</pre>

<h3>3. type()</h3>
<p>Returns the data type of a value.</p>
<pre>
x = 10
print(type(x))
</pre>

<h3>4. len()</h3>
<p>Returns the length of a string, list, or tuple.</p>
<pre>
text = "Python"
print(len(text))
</pre>

<h3>5. int()</h3>
<p>Converts a value into an integer.</p>
<pre>
x = "10"
print(int(x))
</pre>

<h3>6. float()</h3>
<p>Converts a value into a float.</p>
<pre>
x = 5
print(float(x))
</pre>

<h3>7. str()</h3>
<p>Converts a value into a string.</p>
<pre>
x = 100
print(str(x))
</pre>

<h3>8. max()</h3>
<p>Returns the largest value.</p>
<pre>
numbers = [10, 20, 30]
print(max(numbers))
</pre>

<h3>9. min()</h3>
<p>Returns the smallest value.</p>
<pre>
numbers = [10, 20, 30]
print(min(numbers))
</pre>

<h3>10. sum()</h3>
<p>Returns the sum of all values.</p>
<pre>
numbers = [1, 2, 3]
print(sum(numbers))
</pre>

<h3>11. abs()</h3>
<p>Returns the absolute (positive) value.</p>
<pre>
x = -15
print(abs(x))
</pre>

<h3>12. round()</h3>
<p>Rounds a number to the nearest integer.</p>
<pre>
x = 3.6
print(round(x))
</pre>

<h1>Strings in Python</h1>

<h2>What is a String?</h2>
<p>
A <strong>string</strong> in Python is a sequence of characters used to
store text data. Strings are enclosed within single quotes (<code>' '</code>),
double quotes (<code>" "</code>), or triple quotes (<code>''' '''</code> or
<code>""" """</code>).
</p>

<h3>Examples</h3>
<pre>
name = "Python"
message = 'Hello World'
text = """Welcome to Python Programming"""
</pre>

<hr>

<h2>Creating a String</h2>
<p>
We create a string by assigning text to a variable.
</p>
<pre>
name = "Python"
</pre>

<h2>Accessing a String</h2>
<p>
Each character in a string has an index position starting from 0.
</p>
<pre>
s = "Python"
print(s[0])   # P
print(s[1])   # y
</pre>


<h2>Mutable or Immutable?</h2>
<p>
Strings in Python are <strong>immutable</strong>.
This means that once a string is created, its value cannot be changed.
</p>

<h3>Example</h3>
<pre>
s = "Python"
s[0] = "J"   # Error
</pre>

<p>
To modify a string, you must create a new string.
</p>

<pre>
s = "Python"
s = "J" + s[1:]
print(s)
</pre>

<h2>Built-in String Functions (Methods)</h2>
<p>
Python provides many built-in methods to perform operations on strings.
</p>

<h3>1. len()</h3>
<p>Returns the length of the string.</p>
<pre>
s = "Python"
print(len(s))
</pre>

<h3>2. lower()</h3>
<p>Converts all characters to lowercase.</p>
<pre>
s = "PYTHON"
print(s.lower())
</pre>

<h3>3. upper()</h3>
<p>Converts all characters to uppercase.</p>
<pre>
s = "python"
print(s.upper())
</pre>

<h3>4. capitalize()</h3>
<p>Converts the first character to uppercase.</p>
<pre>
s = "python"
print(s.capitalize())
</pre>

<h3>5. title()</h3>
<p>Converts the first letter of each word to uppercase.</p>
<pre>
s = "python programming"
print(s.title())
</pre>

<h3>6. strip()</h3>
<p>Removes spaces from the beginning and end of the string.</p>
<pre>
s = "  hello  "
print(s.strip())
</pre>

<h3>7. replace()</h3>
<p>Replaces one substring with another.</p>
<pre>
s = "I like Java"
print(s.replace("Java", "Python"))
</pre>

<h3>8. split()</h3>
<p>Splits the string into a list.</p>
<pre>
s = "Python is easy"
print(s.split())
</pre>

<h3>9. find()</h3>
<p>Returns the index of the first occurrence of a substring.</p>
<pre>
s = "Python"
print(s.find("t"))
</pre>

<h3>10. count()</h3>
<p>Counts the number of occurrences of a character or substring.</p>
<pre>
s = "banana"
print(s.count("a"))
</pre>
<h2>11. isnumeric()</h2>
<p>
Checks whether the string contains only numeric characters.
</p>
<pre>
s = "12345"
print(s.isnumeric())
</pre>

<h2>12.isalnum()</h2>
<p>
Checks whether the string contains only alphabets and numbers.
</p>
<pre>
s = "Python123"
print(s.isalnum())
</pre>
<h2>13. isalpha()</h2>
<p>
Checks whether the string contains only alphabets.
</p>
<pre>
s = "Python"
print(s.isalpha())
</pre>

<h2>14.islower()</h2>
<p>
Checks whether the string contains only lowercase letters.
</p>
<pre>
s = "python"
print(s.islower())
</pre>
<h2>15. isupper()</h2>
<p>
Checks whether the string contains only uppercase letters.
</p>
<pre>
s = "PYTHON"
print(s.isupper())
</pre>

<h2>16. startswith()</h2>
<p>
Checks whether the string starts with the given value.
</p>
<pre>
s = "Python Programming"
print(s.startswith("Python"))
</pre>

<h2>17. endswith()</h2>
<p>
Checks whether the string ends with the given value.
</p>
<pre>
s = "Python Programming"
print(s.endswith("Programming"))
</pre>

<h1>Python Lists</h1>

<h2> What is a List?</h2>
<p>
A <strong>list</strong> in Python is a collection of items which can be of 
any data type. Lists are <strong>ordered, changeable (mutable)</strong>, 
and allow duplicate values.
</p>

<h2>Creating a List</h2>
<pre>
fruits = ["apple", "banana", "cherry"]
numbers = [1, 2, 3, 4, 5]
mixed = ["Python", 10, 3.14, True]
</pre>

<h2>Accessing List Items (Indexing)</h2>
<pre>
fruits = ["apple", "banana", "cherry"]
print(fruits[0])   # apple
print(fruits[1])   # banana
print(fruits[-1])  # cherry (last item)
</pre>
<h2>Slicing lists</h2>
<p>
List slicing is a technique in Python to access a <strong>subset of elements</strong> 
from a list. You can extract elements by specifying a <strong>start index</strong>, 
an <strong>end index</strong>, and an optional <strong>step</strong>.
</p>

<h2>Slicing Formula:</h2>
<p>
<code>list_name[start : end : step]</code>
</p>
<ul>
  <li><strong>start</strong> → index to start from (inclusive)</li>
  <li><strong>end</strong> → index to go up to (exclusive)</li>
  <li><strong>step</strong> → number of elements to skip (optional, default = 1)</li>
</ul>

<h2>Example:</h2>
<pre>
numbers = [10, 20, 30, 40, 50]

#Slice the list from index 1 to 4
subset = numbers[1:4]

 #Output: [20, 30, 40]
</pre>

<h2>Python Lists are Mutable</h2>
<p>
In Python, <strong>mutable</strong> means the data can be changed after it is created.  
Unlike strings or tuples, lists can be modified — you can change, add, or remove elements.
</p>
<h1>Built-in Functions in lists </h1>

<h2>1. append()</h2>
<p>Adds an item to the end of the list.</p>
<pre>
fruits = ["apple", "banana", "cherry"]
fruits.append("kiwi")
print(fruits)  # ["apple", "banana", "cherry", "kiwi"]
</pre>

<h2>2. insert()</h2>
<p>Adds an item at a specific index.</p>
<pre>
fruits = ["apple", "banana", "cherry"]
fruits.insert(1, "mango")  # Insert at index 1
print(fruits)  # ["apple", "mango", "banana", "cherry"]
</pre>

<h2>3. remove()</h2>
<p>Removes the first occurrence of a value.</p>
<pre>
fruits = ["apple", "banana", "cherry", "banana"]
fruits.remove("banana")
print(fruits)  # ["apple", "cherry", "banana"]
</pre>

<h2>4. pop()</h2>
<p>Removes an item by index and returns it. By default removes the last item.</p>
<pre>
fruits = ["apple", "banana", "cherry"]
item = fruits.pop()  # Removes last item
print(item)   # cherry
print(fruits) # ["apple", "banana"]
</pre>

<h2>5. del</h2>
<p>Deletes an item at a specific index or the entire list.</p>
<pre>
fruits = ["apple", "banana", "cherry"]
del fruits[1]
print(fruits)  # ["apple", "cherry"]
</pre>

<h2>6. len()</h2>
<p>Returns the number of items in a list.</p>
<pre>
numbers = [1, 2, 3, 4]
print(len(numbers))  # 4
</pre>

<h2>7. sort()</h2>
<p>Sorts the list in ascending order.</p>
<pre>
numbers = [4, 2, 1, 3]
numbers.sort()
print(numbers)  # [1, 2, 3, 4]
</pre>

<h2>8. reverse()</h2>
<p>Reverses the order of the list.</p>
<pre>
numbers = [1, 2, 3, 4]
numbers.reverse()
print(numbers)  # [4, 3, 2, 1]
</pre>

<h2>9. count()</h2>
<p>Counts how many times a value appears in the list.</p>
<pre>
fruits = ["apple", "banana", "apple", "cherry"]
print(fruits.count("apple"))  # 2
</pre>

<h2>10. index()</h2>
<p>Returns the index of the first occurrence of a value.</p>
<pre>
fruits = ["apple", "banana", "cherry"]
print(fruits.index("banana"))  # 1
</pre>

<h2>11. extend()</h2>
<p>Adds multiple items from another list to the end of the current list.</p>
<pre>
fruits = ["apple", "banana"]
more_fruits = ["mango", "kiwi"]
fruits.extend(more_fruits)
print(fruits)  # ["apple", "banana", "mango", "kiwi"]
</pre>

<h2>12. clear()</h2>
<p>Removes all items from the list.</p>
<pre>
fruits = ["apple", "banana", "cherry"]
fruits.clear()
print(fruits)  # []
</pre>

<h1>Python Tuples</h1>

<h2>Step 1: What is a Tuple?</h2>
<p>
A <strong>tuple</strong> in Python is an ordered collection of items, similar to a list, 
but it is <strong>immutable</strong>.  
Tuples allow duplicate elements and can contain different data types.
</p>

<h2>Step 2: Creating a Tuple</h2>
<pre>
Using parentheses
fruits = ("apple", "banana", "cherry")

Using tuple() constructor
numbers = tuple([1, 2, 3, 4])

Tuple with different data types
mixed = ("Python", 10, 3.14, True)
</pre>

<h2>Step 3: Accessing Tuple Elements (Indexing)</h2>
<pre>
fruits = ("apple", "banana", "cherry")
print(fruits[0])   # apple
print(fruits[1])   # banana
print(fruits[-1])  # cherry (last element)
</pre>

<h2>Step 4: Slicing Tuples</h2>
<pre>
numbers = (10, 20, 30, 40, 50)
print(numbers[1:4])   # (20, 30, 40)
print(numbers[:3])    # (10, 20, 30)
print(numbers[2:])    # (30, 40, 50)
print(numbers[::-1])  # (50, 40, 30, 20, 10)
</pre>

<h2>Step 5: Tuples are Immutable</h2>
<p>
Once a tuple is created, you cannot change its elements.
</p>
<pre>
fruits = ("apple", "banana", "cherry")
# fruits[1] = "orange"   # This will cause an error
</pre>

<h2>Step 6: Tuple Built-in Functions</h2>
<ul>
  <li><code>len()</code> – returns the number of elements</li>
  <li><code>count()</code> – counts occurrences of a value</li>
  <li><code>index()</code> – returns the index of the first occurrence of a value</li>
</ul>

<h2>Step 7: Example of Tuple Functions</h2>
<pre>
numbers = (1, 2, 3, 2, 4, 2)
print(len(numbers))     # 6
print(numbers.count(2)) # 3
print(numbers.index(3)) # 2
</pre>

<h2>Step 8: Advantages of Tuples</h2>
<ul>
  <li>Tuples are immutable, so their data is safe from accidental modification</li>
  <li>Tuples can be used as keys in dictionaries</li>
  <li>Tuples are faster than lists for iteration</li>
</ul>
<h2> Step 9:List vs Tuple</h2>

<p>
Lists are <strong>mutable</strong> (can be changed), while tuples are <strong>immutable</strong> (cannot be changed).
</p>

<h2>Example:</h2>
<pre>
<h3>List (mutable)</h3>
fruits_list = ["apple", "banana", "cherry"]
fruits_list[1] = "orange"   # Change element
fruits_list.append("kiwi")  # Add element
print("List:", fruits_list)  # Output: ['apple', 'orange', 'cherry', 'kiwi']


<h3>Tuple (immutable)</h3>
fruits_tuple = ("apple", "banana", "cherry")
#fruits_tuple[1] = "orange"  # This will cause an error
print("Tuple:", fruits_tuple)  # Output: ('apple', 'banana', 'cherry')
</pre>

<h1>Python Sets</h1>

<h2>Step 1: What is a Set?</h2>
<p>
A <strong>set</strong> in Python is an <strong>unordered</strong> collection of unique elements.  
Sets are <strong>mutable</strong> but cannot contain duplicate items.
</p>

<h2>Step 2: Creating a Set</h2>
<pre>
#Using curly braces
fruits = {"apple", "banana", "cherry"}
# Using set() constructor
numbers = set([1, 2, 3, 4, 4, 2])
print(numbers)  # Output: {1, 2, 3, 4} (duplicates removed)
</pre>

<h2>Step 3: Accessing Elements</h2>
<p>
Sets are unordered, so you cannot access elements by index.  
You can loop through a set to access its elements.
</p>
<pre>
fruits = {"apple", "banana", "cherry"}
for fruit in fruits:
    print(fruit)
</pre>
<h1>Python Set Built-functions</h1>

<h2>1. add()</h2>
<p>Adds a single element to the set.</p>
<pre>
fruits = {"apple", "banana", "cherry"}
fruits.add("kiwi")
print(fruits)  # Output: {'apple', 'banana', 'cherry', 'kiwi'}
</pre>

<h2>2. remove()</h2>
<p>Removes an element from the set. Raises an error if the element does not exist.</p>
<pre>
fruits = {"apple", "banana", "cherry"}
fruits.remove("banana")
print(fruits)  # Output: {'apple', 'cherry'}
</pre>

<h2>3. discard()</h2>
<p>Removes an element from the set. Does not raise an error if the element does not exist.</p>
<pre>
fruits = {"apple", "banana", "cherry"}
fruits.discard("orange")  # No error
print(fruits)  # Output: {'apple', 'banana', 'cherry'}
</pre>

<h2>4. pop()</h2>
<p>Removes and returns an arbitrary element from the set.</p>
<pre>
fruits = {"apple", "banana", "cherry"}
item = fruits.pop()
print(item)    # Output: could be any element
print(fruits)  # Remaining elements
</pre>

<h2>5. clear()</h2>
<p>Removes all elements from the set.</p>
<pre>
fruits = {"apple", "banana", "cherry"}
fruits.clear()
print(fruits)  # Output: set()
</pre>

<h2>6. union()</h2>
<p>Returns a new set containing all elements from both sets.</p>
<pre>
A = {1, 2, 3}
B = {3, 4, 5}
print(A.union(B))  # Output: {1, 2, 3, 4, 5}
</pre>

<h2>7. intersection()</h2>
<p>Returns a new set with elements common to both sets.</p>
<pre>
A = {1, 2, 3}
B = {3, 4, 5}
print(A.intersection(B))  # Output: {3}
</pre>

<h2>8. difference()</h2>
<p>Returns a new set with elements in the first set but not in the second.</p>
<pre>
A = {1, 2, 3}
B = {3, 4, 5}
print(A.difference(B))  # Output: {1, 2}
print(B.difference(A))  # Output: {4, 5}
</pre>

<h1>Python Dictionary </h1>

<h2>Step 1: What is a Dictionary?</h2>
<p>
A <strong>dictionary</strong> in Python is an <strong>unordered</strong> collection of <strong>key-value pairs</strong>.  
Dictionaries are <strong>mutable</strong> and allow fast access to values using keys.  
Keys must be <strong>unique</strong> and <strong>immutable</strong> (like strings, numbers, or tuples).
</p>

<h2>Step 2: Creating a Dictionary</h2>
<pre>
# Using curly braces
student = {"name": "Alice", "age": 20, "grade": "A"}

#Using dict() constructor
student = dict(name="Alice", age=20, grade="A")
</pre>

<h2>Step 3: Accessing Values</h2>
<pre>
student = {"name": "Alice", "age": 20, "grade": "A"}

#Access by key
print(student["name"])  # Alice
print(student.get("age"))  # 20
</pre>

<h2>Python Dictionaries are Mutable</h2>
<p>
Dictionaries in Python are <strong>mutable</strong>, which means you can change, add, or remove key-value pairs after creation.
</p>

<h1>Python Dictionary Built-in Functions</h1>
<h2>1. keys()</h2>
<p>Returns all the keys in a dictionary.</p>
<pre>
print(student.keys())  # Output: dict_keys(['name', 'age', 'grade'])
</pre>

<h2>2. values()</h2>
<p>Returns all the values in a dictionary.</p>
<pre>
print(student.values())  # Output: dict_values(['Alice', 21, 'A'])
</pre>

<h2>3. items()</h2>
<p>Returns all key-value pairs as tuples.</p>
<pre>
print(student.items())  
# Output: dict_items([('name', 'Alice'), ('age', 21), ('grade', 'A')])
</pre>

<h2>4. get()</h2>
<p>Returns the value for the specified key. Returns None if key does not exist.</p>
<pre>
print(student.get("age"))    # Output: 21
print(student.get("city"))   # Output: None
</pre>

<h2>5. pop()</h2>
<p>Removes the specified key and returns its value.</p>
<pre>
age = student.pop("age")
print(age)      # Output: 21
print(student)  # Output: {'name': 'Alice', 'grade': 'A'}
</pre>

<h2>6. popitem()</h2>
<p>Removes and returns the last inserted key-value pair as a tuple.</p>
<pre>
item = student.popitem()
print(item)     # Output: ('grade', 'A')
print(student)  # Output: {'name': 'Alice'}
</pre>

<h2>7. update()</h2>
<p>Updates the dictionary with new key-value pairs.</p>
<pre>
student.update({"age": 22, "city": "New York"})
print(student)  
# Output: {'name': 'Alice', 'age': 22, 'city': 'New York'}
</pre>

<h2>8. clear()</h2>
<p>Removes all items from the dictionary.</p>
<pre>
student.clear()
print(student)  # Output: {}
</pre>
<h1>Dictionary vs Set vs List</h1>
<ul>
  <li><strong>List:</strong> Ordered collection of elements. Mutable. Allows duplicates. Defined using <code>[]</code>.</li>
  <li><strong>Set:</strong> Unordered collection of unique elements. Mutable. Defined using <code>{}</code> or <code>set()</code>.</li>
  <li><strong>Dictionary:</strong> Unordered collection of key-value pairs. Mutable. Keys must be unique and immutable. Defined using <code>{key: value}</code>.</li>
</ul>

<h2>1. Syntax Examples</h2>
<pre>
#List
fruits_list = ["apple", "banana", "cherry"]

#Set
fruits_set = {"apple", "banana", "cherry"}

#Dictionary
student_dict = {"name": "Alice", "age": 21}
</pre>
<h2>2. Summary Table</h2>
<table>
  <tr>
    <th>Feature</th>
    <th>List</th>
    <th>Set</th>
    <th>Dictionary</th>
  </tr>
  <tr>
    <td>Ordered</td>
    <td>Yes</td>
    <td>No</td>
    <td>No (keys unordered)</td>
  </tr>
  <tr>
    <td>Mutable</td>
    <td>Yes</td>
    <td>Yes</td>
    <td>Yes</td>
  </tr>
  <tr>
    <td>Duplicates Allowed</td>
    <td>Yes</td>
    <td>No</td>
    <td>Keys No, Values Yes</td>
  </tr>
  <tr>
    <td>Access by Index/Key</td>
    <td>Index</td>
    <td>No Index</td>
    <td>Key</td>
  </tr>
  <tr>
    <td>Use Case</td>
    <td>Ordered data collection</td>
    <td>Unique items, mathematical set operations</td>
    <td>Key-value mapping, fast lookup</td>
  </tr>
</table>

<h1>2.Intermediate Python</h1>

<p>
Intermediate Python focuses on writing efficient, clean, and reusable code.
At this level, learners already understand Python basics such as variables,
loops, data types, and functions.
</p>
<h2>What You Learn in Intermediate Python</h2>

<ul>
  <li>Advanced Functions and Arguments</li>
  <li>Lambda Functions</li>
  <li>List, Set, and Dictionary Comprehensions</li>
  <li>File Handling</li>
  <li>Exception Handling</li>
  <li>Modules and Packages</li>
  <li>Object-Oriented Programming (OOP)</li>
</ul>

<h2>Why Learn Intermediate Python?</h2>

<ul>
  <li>Write efficient and reusable code</li>
  <li>Improve problem-solving skills</li>
  <li>Prepare for Advanced Python topics</li>
  <li>Build real-world applications</li>
</ul>

<h1>Python Control Statements</h1>

<p>
Control statements in Python are used to control the flow of execution of a program.
They help make decisions, repeat tasks, and manage program logic effectively.
</p>

<h3>Types of Control Statements</h3>

<ul>
  <li>1.Conditional Statements</li>
  <li>2.Looping Statements</li>
  <li>3.Jump Statements</li>
</ul>

<h2>1. Conditional Statements</h2>

<p>
Conditional statements execute code based on conditions.
</p>

<hr>

<h3>1. if Statement</h3>

<p>
The <b>if</b> statement is used to execute a block of code only when a given
condition is true. If the condition is false, the code inside the <b>if</b>
block is skipped.
</p>
<p><b>Syntax:</b></p>

<pre>
if condition:
    statement
</pre>

<p><b>Example:</b></p>

<pre>
num = 10
if num > 0:
    print("Positive number")
</pre>

<hr>

<h3>2. if-else Statement</h3>

<p>
The <b>if-else</b> statement provides two paths of execution.
If the condition is true, the <b>if</b> block runs.
If the condition is false, the <b>else</b> block runs.
</p>


<p><b>Syntax:</b></p>

<pre>
if condition:
    statement
else:
    statement
</pre>

<p><b>Example:</b></p>

<pre>
num = 7
if num % 2 == 0:
    print("Even")
else:
    print("Odd")
</pre>

<hr>

<h3>3. if-elif-else Statement</h3>

<p>
The <b>elif</b> (else if) statement is used to check multiple conditions.
When one condition becomes true, its block is executed and the rest
are skipped.
</p>
<p><b>Syntax:</b></p>

<pre>
if condition1:
    statement
elif condition2:
    statement
else:
    statement
</pre>

<p><b>Example:</b></p>

<pre>
marks = 85
if marks >= 90:
    print("Grade A")
elif marks >= 60:
    print("Grade B")
else:
    print("Grade C")
</pre>

<h3>4.Nested if Statement</h3>

<p>
A nested <b>if</b> statement means placing one <b>if</b> condition inside another
<b>if</b> or <b>else</b> block. It is used when a decision depends on multiple conditions.
</p>

<p><b>Syntax:</b></p>

<pre>
if condition1:
    if condition2:
        statement
    else:
        statement
else:
    statement
</pre>

<p><b>Example:</b></p>

<pre>
num = 15

if num > 0:
    if num % 2 == 0:
        print("Positive Even number")
    else:
        print("Positive Odd number")
else:
    print("Negative number")
</pre>

<h2>2.Looping Statements</h2>

<p>
Looping statements are used to execute a block of code repeatedly
as long as a condition is satisfied or for each item in a sequence.
</p>

<hr>

<h3>Types of Looping Statements</h3>

<ul>
  <li>1.for loop</li>
  <li>2.while loop</li>
  <li>3.nested loops</li>
</ul>

<hr>

<h3>1. for Loop</h3>

<p>
The <b>for</b> loop is used to iterate over a sequence such as a list,
tuple, string, or range.
</p>

<p><b>Syntax:</b></p>

<pre>
for variable in sequence:
    statement
</pre>

<p><b>Example:</b></p>

<pre>
for i in range(1, 6):
    print(i)
</pre>

<hr>

<h3>2. while Loop</h3>

<p>
The <b>while</b> loop executes a block of code as long as the given
condition is true.
</p>

<p><b>Syntax:</b></p>

<pre>
while condition:
    statement
</pre>

<p><b>Example:</b></p>

<pre>
i = 1
while i <= 5:
    print(i)
    i += 1
</pre>

<hr>

<h3>3. Nested Loops</h3>

<p>
A nested loop is a loop inside another loop.
The inner loop executes completely for each iteration of the outer loop.
</p>

<p><b>Syntax:</b></p>

<pre>
for variable1 in sequence:
    for variable2 in sequence:
        statement
</pre>

<p><b>Example:</b></p>

<pre>
for i in range(1, 4):
    for j in range(1, 3):
        print(i, j)
</pre>

<hr>

<h3>Important Loop Control Statements</h3>

<ul>
  <li><b>break</b> → Terminates the loop</li>
  <li><b>continue</b> → Skips the current iteration</li>
  <li><b>pass</b> → Acts as a placeholder</li>
</ul>

<h2>3.Jumping Statements</h2>

<p>
Jumping statements are used to change the normal flow of execution
inside loops or conditional blocks. They help skip, stop, or pass
control in a program.
</p>

<hr>

<h3>Types of Jumping Statements</h3>

<ul>
  <li>1.break</li>
  <li>2.continue</li>
  <li>3.pass</li>
</ul>

<hr>

<h3>1. break Statement</h3>

<p>
The <b>break</b> statement is used to immediately terminate the loop
when a specific condition is met.
</p>

<p><b>Syntax:</b></p>

<pre>
break
</pre>

<p><b>Example:</b></p>

<pre>
for i in range(1, 10):
    if i == 5:
        break
    print(i)
</pre>

<hr>

<h3>2. continue Statement</h3>

<p>
The <b>continue</b> statement skips the current iteration of the loop
and moves to the next iteration.
</p>

<p><b>Syntax:</b></p>

<pre>
continue
</pre>

<p><b>Example:</b></p>

<pre>
for i in range(1, 6):
    if i == 3:
        continue
    print(i)
</pre>

<hr>

<h3>3. pass Statement</h3>

<p>
The <b>pass</b> statement is a null operation.
It is used as a placeholder where a statement is syntactically required
but no action is needed.
</p>

<p><b>Syntax:</b></p>

<pre>
pass
</pre>

<p><b>Example:</b></p>

<pre>
for i in range(3):
    if i == 1:
        pass
    print(i)
</pre>

<h1>Functions in Python</h1>

<p>
A function in Python is a block of reusable code that performs a specific task.
Functions help make programs modular, readable, and easy to maintain.
</p>

<hr>

<h3>Why Use Functions?</h3>

<ul>
  <li>Code reusability</li>
  <li>Improves readability</li>
  <li>Reduces code duplication</li>
  <li>Makes debugging easier</li>
</ul>

<hr>

<h3>Syntax of a Function</h3>

<pre>
def function_name(parameters):
    statement
    return value
</pre>
<h3>Function Example</h3>

<p>
This function takes two numbers and prints their sum.
</p>

<pre>
def add(a, b):
    print(a + b)

add(5, 3)
</pre>

<p><b>Output:</b></p>

<pre>
8
</pre>
<hr>

<h3>1. Function Without Parameters</h3>

<p><b>Example:</b></p>

<pre>
def greet():
    print("Welcome to Python")

greet()
</pre>

<hr>

<h3>2. Function With Parameters</h3>

<p><b>Example:</b></p>

<pre>
def add(a, b):
    print(a + b)

add(10, 20)
</pre>

<hr>

<h3>3. Function With Return Statement</h3>

<p>
The <b>return</b> statement sends a value back to the caller.
</p>

<p><b>Example:</b></p>

<pre>
def square(num):
    return num * num

result = square(4)
print(result)
</pre>

<hr>

<h3>4. Default Parameter Function</h3>

<p>
Default parameters allow a function to use a default value if no argument is provided.
</p>

<p><b>Example:</b></p>

<pre>
def greet(name="User"):
    print("Hello", name)

greet()
greet("Pavani")
</pre>

<hr>

<h3>5. Keyword Arguments</h3>

<p>
Arguments can be passed using parameter names.
</p>

<p><b>Example:</b></p>

<pre>
def student(name, age):
    print(name, age)

student(age=20, name="Pavani")
</pre>

<h2>Local and Global Variables in Python</h2>

<p>
Variables in Python are classified based on where they are declared
and how they are accessed.
</p>

<hr>

<h3>1. Local Variable</h3>

<p>
A <b>local variable</b> is a variable that is declared inside a function.
It can be accessed only within that function.
</p>

<p><b>Example:</b></p>

<pre>
def show():
    x = 10   # local variable
    print(x)

show()
</pre>

<p><b>Output:</b></p>

<pre>
10
</pre>

<hr>

<h3>2. Global Variable</h3>

<p>
A <b>global variable</b> is a variable that is declared outside all functions.
It can be accessed anywhere in the program.
</p>

<p><b>Example:</b></p>

<pre>
y = 20   # global variable

def display():
    print(y)

display()
</pre>

<p><b>Output:</b></p>

<pre>
20
</pre>

<hr>

<h2>Differences Between Local and Global Variables</h3>

<table>
  <tr>
    <th>Local Variable</th>
    <th>Global Variable</th>
  </tr>
  <tr>
    <td>Declared inside a function</td>
    <td>Declared outside a function</td>
  </tr>
  <tr>
    <td>Accessible only within the function</td>
    <td>Accessible throughout the program</td>
  </tr>
  <tr>
    <td>Created when function is called</td>
    <td>Created when program starts</td>
  </tr>
  <tr>
    <td>Destroyed after function execution</td>
    <td>Exists until program ends</td>
  </tr>
</table>

<h2>return Statement in Python</h2>
<p>
The <b>return</b> statement is used inside a function to send a value
back to the caller. Once <b>return</b> is executed, the function stops
its execution.
</p>

<hr>

<h3>Syntax</h3>

<pre>
return value
</pre>

<hr>

<h3>Simple Example</h3>

<pre>
def add(a, b):
    return a + b

result = add(5, 3)
print(result)
</pre>

<p><b>Output:</b></p>

<pre>
8
</pre>

<h2>Modularization Using Functions in Python</h2>

<p>
<b>Modularization</b> means dividing a large program into smaller,
independent, and manageable parts called <b>modules</b> or <b>functions</b>.
Each function performs a specific task.
</p>

<hr>

<h3>Why Modularization?</h3>

<ul>
  <li>Makes code easier to understand</li>
  <li>Improves code reusability</li>
  <li>Easy to debug and maintain</li>
  <li>Reduces code complexity</li>
</ul>

<hr>

<h3> Example of Modularization</h3>

<p>
Instead of writing all logic in one place, we divide the program
into multiple functions.
</p>

<pre>
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def multiply(a, b):
    return a * b

result1 = add(10, 5)
result2 = subtract(10, 5)
result3 = multiply(10, 5)

print(result1)
print(result2)
print(result3)
</pre>

<p><b>Output:</b></p>

<pre>
15
5
50
</pre>

<h2>*args and **kwargs in Python</h2>

<p>
<b>*args</b> and <b>**kwargs</b> are used in functions to pass a variable
number of arguments.
</p>

<hr>

<h3>1. *args (Non-Keyword Arguments)</h3>

<p>
<b>*args</b> allows a function to accept multiple positional arguments.
The arguments are stored as a tuple.
</p>

<p><b>Syntax:</b></p>

<pre>
def function_name(*args):
    statement
</pre>

<p><b>Example:</b></p>

<pre>
def add_numbers(*args):
    total = 0
    for i in args:
        total += i
    return total

print(add_numbers(10, 20, 30))
</pre>

<p><b>Output:</b></p>

<pre>
60
</pre>

<hr>

<h3>2. **kwargs (Keyword Arguments)</h3>

<p>
<b>**kwargs</b> allows a function to accept multiple keyword arguments.
The arguments are stored as a dictionary.
</p>

<p><b>Syntax:</b></p>

<pre>
def function_name(**kwargs):
    statement
</pre>

<p><b>Example:</b></p>

<pre>
def show_details(**kwargs):
    for key, value in kwargs.items():
        print(key, ":", value)

show_details(name="Pavani", age=22)
</pre>

<p><b>Output:</b></p>

<pre>
name : Pavani
age : 22
</pre>

<h1>Lambda Functions in Python</h1>

<p>
A <b>lambda function</b> is a small anonymous function written in a single line.
It can take any number of arguments but only one expression.
</p>

<hr>

<p><b>Syntax:</b></p>

<pre>
lambda arguments: expression
</pre>

<hr>

<p><b>Example:</b></p>

<pre>
square = lambda x: x * x
print(square(5))
</pre>

<p><b>Output:</b></p>

<pre>
25
</pre>

<hr>

<h4>Key Points</h4>

<ul>
  <li>No function name is required</li>
  <li>Written in a single line</li>
  <li>Returns value automatically</li>
  <li>Used for short operations</li>
</ul>

<h2>map(), filter(), and reduce() in Python</h2>

<p>
The functions <b>map</b>, <b>filter</b>, and <b>reduce</b> are used to perform
operations on collections like lists in a clean and efficient way.
</p>

<hr>

<h3>1. map()</h3>

<p><b>Purpose:</b></p>
<p>
<b>map()</b> is used to <b>apply the same operation to every element</b>
in an iterable and return the modified elements.
</p>

<p><b>Syntax:</b></p>

<pre>
map(function, iterable)
</pre>

<p><b>Example:</b></p>

<pre>
numbers = [1, 2, 3, 4]

result = map(lambda x: x * 2, numbers)
print(list(result))
</pre>

<p><b>Output:</b></p>

<pre>
[2, 4, 6, 8]
</pre>

<hr>

<h3>2. filter()</h3>

<p><b>Purpose:</b></p>
<p>
<b>filter()</b> is used to <b>select elements</b> from an iterable
that satisfy a specific condition.
</p>

<p><b>Syntax:</b></p>

<pre>
filter(function, iterable)
</pre>

<p><b>Example:</b></p>

<pre>
numbers = [1, 2, 3, 4, 5, 6]

result = filter(lambda x: x % 2 == 0, numbers)
print(list(result))
</pre>

<p><b>Output:</b></p>

<pre>
[2, 4, 6]
</pre>

<hr>

<h3>3. reduce()</h3>

<p><b>Purpose:</b></p>
<p>
<b>reduce()</b> is used to <b>combine all elements</b> of an iterable
into a <b>single value</b>.
</p>

<p><b>Note:</b> <b>reduce()</b> must be imported from the <b>functools</b> module.</p>

<p><b>Syntax:</b></p>

<pre>
reduce(function, iterable)
</pre>

<p><b>Example:</b></p>

<pre>
from functools import reduce

numbers = [1, 2, 3, 4]

result = reduce(lambda x, y: x + y, numbers)
print(result)
</pre>

<p><b>Output:</b></p>

<pre>
10
</pre>

<h1>Recursion in Python</h2>

<p>
<b>Recursion</b> is a technique in which a function calls itself
to solve a problem by breaking it into smaller subproblems.
</p>

<hr>

<h3>Purpose of Recursion</h3>

<ul>
  <li>Solve problems that can be divided into smaller similar problems</li>
  <li>Useful for mathematical calculations</li>
  <li>Simplifies code for complex logic</li>
</ul>

<hr>

<h3>Syntax of Recursive Function</h3>

<pre>
def function_name():
    if base_condition:
        return value
    return function_name()
</pre>

<hr>

<h3> Example (Factorial)</h3>

<pre>
def factorial(n):
    if n == 1:
        return 1
    return n * factorial(n - 1)

print(factorial(5))
</pre>

<p><b>Output:</b></p>

<pre>
120
</pre>

<hr>

<h3>Key Points</h3>

<ul>
  <li>A recursive function must have a <b>base condition</b></li>
  <li>Without base condition, recursion leads to infinite calls</li>
  <li>Each function call uses memory (stack)</li>
  <li>Recursion can be replaced with loops in many cases</li>
</ul>

<hr>

<h3>When to Use Recursion?</h3>

<ul>
  <li>Tree and graph traversal</li>
  <li>Factorial, Fibonacci series</li>
  <li>Divide and conquer problems</li>
</ul>
<h1>Comprehensions in Python</h1>

<p>
<b>Comprehensions</b> provide a short and readable way to create collections
such as lists, sets, and dictionaries in Python.
</p>

<hr>

<h3>Purpose of Comprehensions</h3>

<ul>
  <li>Write clean and concise code</li>
  <li>Improve readability</li>
  <li>Replace long loops</li>
  <li>Efficient data processing</li>
</ul>

<hr>

<h3>Types of Comprehensions</h3>

<ul>
  <li>1.List Comprehension</li>
  <li>2.Set Comprehension</li>
  <li>3.Dictionary Comprehension</li>
</ul>

<hr>

<h3>1. List Comprehension</h3>

<p><b>Purpose:</b> Used to create a new list by applying an expression to each item.</p>

<p><b>Syntax:</b></p>

<pre>
[expression for item in iterable if condition]
</pre>

<p><b>Example:</b></p>

<pre>
numbers = [1, 2, 3, 4, 5]

squares = [n * n for n in numbers]
print(squares)
</pre>

<p><b>Output:</b></p>

<pre>
[1, 4, 9, 16, 25]
</pre>

<hr>

<h3>2. Set Comprehension</h3>

<p><b>Purpose:</b> Used to create a set with unique values.</p>

<p><b>Syntax:</b></p>

<pre>
{expression for item in iterable if condition}
</pre>

<p><b>Example:</b></p>

<pre>
numbers = [1, 2, 2, 3, 4, 4]

unique_numbers = {n for n in numbers}
print(unique_numbers)
</pre>

<p><b>Output:</b></p>

<pre>
{1, 2, 3, 4}
</pre>

<hr>

<h3>3. Dictionary Comprehension</h3>

<p><b>Purpose:</b> Used to create a dictionary from an iterable.</p>

<p><b>Syntax:</b></p>

<pre>
{key: value for item in iterable if condition}
</pre>

<p><b>Example:</b></p>

<pre>
numbers = [1, 2, 3, 4]

squares = {n: n * n for n in numbers}
print(squares)
</pre>

<p><b>Output:</b></p>

<pre>
{1: 1, 2: 4, 3: 9, 4: 16}
</pre>

<h1>File Handling in Python</h1>

<p>
<b>File handling</b> in Python is used to create, read, write, and append data
to files stored on the system.
File handling in Python refers to the process of creating, reading,
writing, and updating files stored on a computer.
It allows programs to store data permanently instead of keeping it only
in memory.
</p>

<hr>

<h3>Purpose of File Handling</h3>

<ul>
  <li>Store data permanently</li>
  <li>Read data from files</li>
  <li>Update or append file content</li>
  <li>Handle large data efficiently</li>
</ul>

<h2>Opening a File in Python</h2>

<p>
Opening a file means making the file available to the program
so that data can be read from or written to it.
Python uses the <b>open()</b> function to open files.
</p>

<hr>

<h3>Syntax</h3>

<pre>
file_object = open("filename", "mode")
</pre>


<hr>

<h3>File Modes</h3>

<ul>
  <li><b>r</b> → Read (default)</li>
  <li><b>w</b> → Write (overwrites file)</li>
  <li><b>a</b> → Append</li>
  <li><b>x</b> → Create new file</li>
</ul>

<hr>

<h3>1. Writing to a File</h3>

<p><b>Example:</b></p>

<pre>
file = open("data.txt", "w")
file.write("Hello Python")
file.close()
</pre>

<p><b>Output:</b></p>

<pre>
data.txt file created with content: Hello Python
</pre>

<hr>

<h3>2. Reading from a File</h3>

<p><b>Example:</b></p>

<pre>
file = open("data.txt", "r")
content = file.read()
print(content)
file.close()
</pre>

<p><b>Output:</b></p>

<pre>
Hello Python
</pre>

<hr>

<h3>3. Appending to a File</h3>

<p><b>Example:</b></p>

<pre>
file = open("data.txt", "a")
file.write("\nWelcome")
file.close()
</pre>

<p><b>Output:</b></p>

<pre>
File updated with new content
</pre>

<hr>

<h3>Using with Statement</h3>

<p>
The <b>with</b> statement automatically closes the file after use.
</p>

<p><b>Example:</b></p>

<pre>
with open("data.txt", "r") as file:
    print(file.read())
</pre>

<h2>dump(), load(), dumps(), and loads() in Python</h2>

<p>
These functions are used in <b>serialization</b> and <b>deserialization</b>.
Serialization means converting Python objects into a byte format,
and deserialization means converting them back into Python objects.
</p>

<hr>

<h3>1. dump()</h3>

<p><b>Purpose:</b></p>
<p>
<b>dump()</b> is used to write (save) Python objects into a file
in serialized form.
</p>

<p><b>Example:</b></p>

<pre>
import pickle

data = [1, 2, 3, 4]

file = open("data.pkl", "wb")
pickle.dump(data, file)
file.close()
</pre>

<hr>

<h3>2. load()</h3>

<p><b>Purpose:</b></p>
<p>
<b>load()</b> is used to read (retrieve) Python objects from a file
and convert them back to original form.
</p>

<p><b>Example:</b></p>

<pre>
import pickle

file = open("data.pkl", "rb")
data = pickle.load(file)
file.close()

print(data)
</pre>

<p><b>Output:</b></p>

<pre>
[1, 2, 3, 4]
</pre>

<hr>

<h3>3. dumps()</h3>

<p><b>Purpose:</b></p>
<p>
<b>dumps()</b> converts a Python object into a byte string
without saving it to a file.
</p>

<p><b>Example:</b></p>

<pre>
import pickle

data = {"name": "Pavani", "age": 22}

byte_data = pickle.dumps(data)
print(byte_data)
</pre>

<hr>

<h3>4. loads()</h3>

<p><b>Purpose:</b></p>
<p>
<b>loads()</b> converts a byte string back into a Python object.
</p>

<p><b>Example:</b></p>

<pre>
import pickle

data = pickle.loads(byte_data)
print(data)
</pre>

<p><b>Output:</b></p>

<pre>
{'name': 'Pavani', 'age': 22}
</pre>

<h1>3.Advanced Python Programming</h1>

<p>
Advanced Python focuses on powerful concepts that help developers write
<strong>efficient, reusable, scalable, and professional-level code</strong>.
It is used in real-world applications such as web development, data science,
automation, machine learning, and software engineering.
</p>
<h3>Why Use Advanced Python?</h3>

<p>
Advanced Python is used to develop <strong>efficient, scalable, and real-world applications</strong>.
It helps programmers write clean, optimized, and professional-quality code.
</p>

<hr>

<h3>Advantages of Advanced Python</h3>

<h3>1️.High Performance</h3>
<p>
Advanced Python concepts such as generators and multithreading improve program
performance and reduce memory usage.
</p>

<h3>2️.Code Reusability</h3>
<p>
Using classes, functions, and modules allows developers to reuse code,
saving time and effort.
</p>

<h3>3️.Better Error Handling</h3>
<p>
Exception handling prevents program crashes and improves application reliability.
</p>

<h3>4️.Clean and Readable Code</h3>
<p>
Advanced features like decorators, lambda functions, and comprehensions
make code short and easy to understand.
</p>

<h3>5️.Support for Large Applications</h3>
<p>
Advanced Python helps manage large projects by organizing code into
modules and packages.
</p>
<h2>Example of Advanced Python</h2>

<p>
Below example shows the use of a <strong>decorator</strong> to enhance a function
without changing its original code.
</p>

<pre><code>
def my_decorator(func):
    def wrapper():
        print("Before function execution")
        func()
        print("After function execution")
    return wrapper

@my_decorator
def greet():
    print("Hello, Advanced Python!")

greet()
</code></pre>

<p><strong>Output:</strong></p>
<pre><code>
Before function execution
Hello, Advanced Python!
After function execution
</code></pre>

<h1>Exception Handling in Python</h1>

<p>
Python provides several blocks to handle runtime errors using
<strong>exception handling</strong>. These blocks help prevent program crashes
and allow smooth execution.
</p>

<hr>

<h2>1.try – except</h2>

<p>
The <strong>try</strong> block contains code that may raise an exception.
The <strong>except</strong> block handles the error if it occurs.
</p>
<pre><code>
try:
    a = 10
    b = 0
    print(a / b)
except ZeroDivisionError:
    print("Division by zero is not allowed")
</code></pre>

<p><strong>Output:</strong></p>
<pre><code>
Division by zero is not allowed
</code></pre>

<hr>

<h2>2.try – except – else</h2>

<p>
The <strong>else</strong> block executes only when no exception occurs
inside the try block.
</p>
<pre><code>
try:
    num = int(input("Enter a number: "))
except ValueError:
    print("Invalid input")
else:
    print("You entered:", num)
</code></pre>

<hr>

<h2>3.try – except – finally</h2>

<p>
The <strong>finally</strong> block always executes, whether an exception
occurs or not. It is mainly used for cleanup operations.
</p>

<pre><code>
try:
    file = open("data.txt", "r")
    print(file.read())
except FileNotFoundError:
    print("File not found")
finally:
    print("File closed successfully")
</code></pre>

<h1>Common Errors in Python</h1>

<p>
Python errors occur when the program cannot be executed correctly.
Understanding these errors helps in debugging and writing reliable code.
</p>

<hr>

<h2>1. SyntaxError</h2>

<p>
<strong>SyntaxError</strong> occurs when Python code does not follow
proper syntax rules.
</p>

<p><strong>Purpose:</strong> Indicates incorrect structure of code.</p>

<pre><code>
# Example
print("Hello"
</code></pre>

<p><strong>Error:</strong> SyntaxError: unexpected EOF while parsing</p>

<hr>

<h2>2. NameError</h2>

<p>
<strong>NameError</strong> occurs when a variable or function name
is not defined.
</p>

<p><strong>Purpose:</strong> Indicates usage of undeclared variables.</p>

<pre><code>
# Example
print(x)
</code></pre>

<p><strong>Error:</strong> NameError: name 'x' is not defined</p>

<hr>

<h2>3. ValueError</h2>

<p>
<strong>ValueError</strong> occurs when a function receives a correct type
but an invalid value.
</p>

<p><strong>Purpose:</strong> Indicates incorrect value usage.</p>

<pre><code>
# Example
num = int("abc")
</code></pre>

<p><strong>Error:</strong> ValueError: invalid literal for int()</p>

<hr>

<h2>4. TypeError</h2>

<p>
<strong>TypeError</strong> occurs when an operation is applied to
incompatible data types.
</p>

<p><strong>Purpose:</strong> Indicates type mismatch.</p>

<pre><code>
# Example
result = "10" + 5
</code></pre>

<p><strong>Error:</strong> TypeError: can only concatenate str (not "int")</p>

<hr>

<h2>5. IndentationError</h2>

<p>
<strong>IndentationError</strong> occurs when indentation is incorrect.
Python uses indentation to define blocks.
</p>

<p><strong>Purpose:</strong> Enforces proper code structure.</p>

<pre><code>
# Example
if True:
print("Hello")
</code></pre>

<p><strong>Error:</strong> IndentationError: expected an indented block</p>

<h2>6. FileNotFoundError</h2>

<p>
<strong>FileNotFoundError</strong> occurs when trying to open a file
that does not exist.
</p>

<p><strong>Purpose:</strong> Prevents file access issues.</p>

<pre><code>
# Example
file = open("data.txt", "r")
</code></pre>

<p><strong>Error:</strong> FileNotFoundError: No such file or directory</p>

<hr>

<h2>7. ZeroDivisionError</h2>

<p>
<strong>ZeroDivisionError</strong> occurs when dividing a number by zero.
</p>

<p><strong>Purpose:</strong> Prevents invalid arithmetic operations.</p>

<pre><code>
# Example
print(10 / 0)
</code></pre>

<p><strong>Error:</strong> ZeroDivisionError: division by zero</p>

<h1>Object-Oriented Programming (OOP) in Python</h1>

<p>
Object-Oriented Programming (OOP) is a programming paradigm that organizes code
using <strong>classes</strong> and <strong>objects</strong>.
Python fully supports OOP concepts, making programs more structured,
reusable, and easy to maintain.
</p>

<hr>

<h2>Why Use OOP in Python?</h2>

<ul>
  <li>Improves code reusability</li>
  <li>Makes programs easier to understand</li>
  <li>Supports large and complex applications</li>
  <li>Enhances security and reliability</li>
  <li>Models real-world problems easily</li>
</ul>

<hr>

<h2>Basic OOP Terms</h2>

<h21.>Class</h3>
<p>
A <strong>class</strong> is a blueprint or template used to create objects.
</p>

<h2>2.Object</h3>
<p>
An <strong>object</strong> is an instance of a class. It represents a real-world entity.
</p>

<hr>

<h3>Creating a Class and Object</h2>

<pre><code>
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def display(self):
        print("Name:", self.name)
        print("Age:", self.age)

s1 = Student("Pavani", 22)
s1.display()
</code></pre>

<hr>

<h2>3.Constructor (__init__)</h2>
<p>
A <strong>constructor</strong> is a special method in Python used to
<strong>initialize object data</strong>.  
In Python, the constructor method is named <code>__init__()</code>.
It is automatically called when an object is created.
</p>

<pre><code>
def __init__(self):
    pass
</code></pre>

<hr>

<h2>Types of Constructors in Python</h2>

<ul>
  <li>1.Default Constructor</li>
  <li>2.Parameterized Constructor</li>
  <li>3.Non-Parameterized Constructor</li>
</ul>

<hr>

<h3>1. Default Constructor</h3>

<p>
A <strong>default constructor</strong> is a constructor that does not take
any arguments except <code>self</code>.  
It initializes default values.
</p>

<pre><code>
class Student:
    def __init__(self):
        self.name = "Pavani"
        self.age = 22

    def display(self):
        print(self.name, self.age)

s = Student()
s.display()
</code></pre>

<hr>

<h3>2. Parameterized Constructor</h3>

<p>
A <strong>parameterized constructor</strong> accepts parameters
and initializes instance variables with user-provided values.
</p>

<pre><code>
class Student:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def display(self):
        print(self.name, self.age)

s1 = Student("Pavani", 22)
s2 = Student("Ravi", 23)

s1.display()
s2.display()
</code></pre>

<hr>

<h3>3. Non-Parameterized Constructor</h3>

<p>
A <strong>non-parameterized constructor</strong> is similar to a default
constructor and does not receive any values from the user.
</p>

<pre><code>
class Demo:
    def __init__(self):
        print("Non-parameterized constructor called")

d = Demo()
</code></pre>

<hr>

<h3>Example: With Constructor</h3>

<p>
In this example, data is initialized automatically using a constructor.
</p>

<pre><code>
class Employee:
    def __init__(self, emp_id, salary):
        self.emp_id = emp_id
        self.salary = salary

    def show(self):
        print("ID:", self.emp_id)
        print("Salary:", self.salary)

e = Employee(101, 50000)
e.show()
</code></pre>

<p>
✔ Data is initialized automatically when the object is created.
</p>

<hr>

<h3>Example: Without Constructor</h3>

<p>
In this example, data is assigned manually using a separate method
instead of a constructor.
</p>

<pre><code>
class Employee:
    def set_data(self, emp_id, salary):
        self.emp_id = emp_id
        self.salary = salary

    def show(self):
        print("ID:", self.emp_id)
        print("Salary:", self.salary)

e = Employee()
e.set_data(101, 50000)
e.show()
</code></pre>
<h2>4.self in Python </h2>

<p>
In Python, <strong>self</strong> refers to the <strong>current object</strong>.
It is used to access and store instance variables and methods that belong
to that object.
</p>

<hr>

<h3>Purpose of <code>self</code></h3>

<ul>
  <li>Refers to the current object</li>
  <li>Stores data specific to an object</li>
</ul>
<hr>

<h3>Example Using <code>self</code></h3>

<pre><code>
class Student:
    def set_data(self, name):
        self.name = name   # instance variable

    def show_data(self):
        print("Name:", self.name)

s1 = Student()
s1.set_data("Pavani")
s1.show_data()
</code></pre>

<hr>
<h1>Inheritance in Python</h1>

<p>
<strong>Inheritance</strong> is an Object-Oriented Programming (OOP) concept
that allows a child class to acquire the properties and methods
of a parent class. It promotes code reusability and logical structure.
</p>

<hr>

<h2>Why Use Inheritance?</h2>

<ul>
  <li>Reusability of code</li>
  <li>Reduces code duplication</li>
  <li>Improves readability</li>
  <li>Supports method overriding</li>
  <li>Models real-world relationships</li>
</ul>

<hr>

<h2>Basic Syntax of Inheritance</h2>

<pre><code>
class Parent:
    # parent class code

class Child(Parent):
    # child class code
</code></pre>

<hr>

<h2>Example of Inheritance</h2>

<pre><code>
class Parent:
    def show(self):
        print("This is Parent class")

class Child(Parent):
    def display(self):
        print("This is Child class")

c = Child()
c.show()
c.display()
</code></pre>

<hr>

<h2>Types of Inheritance in Python</h2>

<ul>
  <li>1.Single Inheritance</li>
  <li>2.Multiple Inheritance</li>
  <li>3.Multilevel Inheritance</li>
  <li>4.Hierarchical Inheritance</li>
  <li>5.Hybrid Inheritance</li>
</ul>

<hr>

<h3>1. Single Inheritance</h3>

<p>
Single inheritance means one child class inherits from exactly one parent class.
It is the simplest form of inheritance and is easy to understand and use.

</p>
<ul>
  <li>One parent → one child</li>
  <li>Promotes code reuse</li>
  <li>Easy to debug and maintain</li>
</ul>
<pre><code>
class Animal:
    def eat(self):
        print("Animal eats")

class Dog(Animal):
    def bark(self):
        print("Dog barks")

d = Dog()
d.eat()
d.bark()
</code></pre>

<hr>

<h3>2. Multiple Inheritance</h3>

<p>
A child class inherits from more than one parent class.
Multilevel inheritance occurs when a class is derived from another derived class.
The inheritance chain continues for multiple levels.
</p>

<ul>
  <li>Grandparent → Parent → Child</li>
  <li>Each level adds new features</li>
  <li>Represents step-by-step hierarchy</li>
</ul>

<pre><code>
class Father:
    def skill1(self):
        print("Father skill")

class Mother:
    def skill2(self):
        print("Mother skill")

class Child(Father, Mother):
    pass

c = Child()
c.skill1()
c.skill2()
</code></pre>

<hr>

<h3>3. Multilevel Inheritance</h3>

<p>
Inheritance in multiple levels (grandparent → parent → child).
Multiple inheritance means a single child class inherits from more than one parent class.
Python supports multiple inheritance, unlike some other programming languages.
</p>

<ul>
  <li>Multiple parents → one child</li>
  <li>Allows combining features from different classes</li>
  <li>Requires careful design to avoid ambiguity</li>
</ul>

<pre><code>
class GrandParent:
    def show1(self):
        print("Grand Parent")

class Parent(GrandParent):
    def show2(self):
        print("Parent")

class Child(Parent):
    def show3(self):
        print("Child")

c = Child()
c.show1()
c.show2()
c.show3()
</code></pre>

<hr>

<h3>4. Hierarchical Inheritance</h3>

<p>
Hierarchical inheritance occurs when multiple child classes inherit
from the same parent class.
</p>

<ul>
  <li>One parent → many children</li>
  <li>Promotes consistency across child classes</li>
  <li>Common functionality is shared</li>
</ul>

<pre><code>
class Vehicle:
    def start(self):
        print("Vehicle started")

class Car(Vehicle):
    pass

class Bike(Vehicle):
    pass

c = Car()
b = Bike()
c.start()
b.start()
</code></pre>

<hr>

<h3>5. Hybrid Inheritance</h3>

<p>
Hybrid inheritance is a combination of two or more types of inheritance.
It is commonly used in complex applications.
</p>

<ul>
  <li>Combination of single, multiple, or multilevel inheritance</li>
  <li>Used in large-scale systems</li>
  <li>Requires proper design planning</li>
</ul>

<pre><code>
class A:
    def showA(self):
        print("Class A")

class B(A):
    def showB(self):
        print("Class B")

class C(A):
    def showC(self):
        print("Class C")

class D(B, C):
    pass

d = D()
d.showA()
d.showB()
d.showC()
</code></pre>

<h2>Advantages of Inheritance</h2>

<ul>
  <li>Code reusability</li>
  <li>Easy maintenance</li>
  <li>Better organization</li>
  <li>Supports polymorphism</li>
</ul>


























































